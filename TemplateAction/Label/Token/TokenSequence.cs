//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成
//     如果重新生成代码，将丢失对此文件所做的更改。
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace TemplateAction.Label.Token
{
    /// <summary>
    /// 标记集
    /// </summary>
    public abstract class TokenSequence
    {
        protected string mTokenInput;
        protected int mPosition;
        protected string mAppendStr;
        public TokenSequence(string input)
        {
            mPosition = 0;
            mTokenInput = input;
            mAppendStr = "";
        }
        public override string ToString()
        {
            PrepareRead();
            return mTokenInput;
        }
        public int Position
        {
            get { return mPosition; }
        }
        public void BackPosition(int len)
        {
            mPosition -= len;
        }
        protected void PrepareRead()
        {
            if (mAppendStr != string.Empty)
            {
                mTokenInput += mAppendStr;
                mAppendStr = string.Empty;
            }
        }
        protected void SkipWhiteSpace()
        {
            while (mPosition < mTokenInput.Length && char.IsWhiteSpace(mTokenInput[mPosition]))
            {
                mPosition++;
            }
        }
        #region 抽象结构
        public abstract BaseToken GenerateToken(string input);
        protected abstract void AppendToken(BaseToken token);
        #endregion
        #region 公用方法
        public string Substring(int startIndex, int length)
        {
            return mTokenInput.Substring(startIndex, length);
        }
        public BaseToken Peek()
        {
            PrepareRead();
            SkipWhiteSpace();
            BaseToken tToken;
            if (mPosition < mTokenInput.Length)
            {
                tToken = GenerateToken(mTokenInput.Substring(mPosition, 1));
            }
            else
            {
                tToken = new UndefinedToken(string.Empty);
            }
            AppendToken(tToken);
            return tToken;
        }

        public BaseToken Pop()
        {
            PrepareRead();
            SkipWhiteSpace();
            BaseToken tToken;
            if (mPosition < mTokenInput.Length)
            {
                tToken = GenerateToken(mTokenInput.Substring(mPosition, 1));
            }
            else
            {
                tToken = new UndefinedToken(string.Empty);
            }
       
            AppendToken(tToken);
            mPosition += tToken.Length;
            return tToken;
        }

        public bool IsEnd()
        {
            return mPosition >= mTokenInput.Length;
        }
        #endregion
        public static TokenSequence operator +(TokenSequence t1, BaseToken t2)
        {
            t1.mAppendStr += t2.ToString();
            return t1;
        }
        public static TokenSequence operator +(BaseToken t1, TokenSequence t2)
        {
            t2.mAppendStr += t1.ToString();
            return t2;
        }
        public static TokenSequence operator +(TokenSequence t1, TokenSequence t2)
        {
            t1.mAppendStr += t2.ToString();
            return t1;
        }
    }

}