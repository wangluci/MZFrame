//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成
//     如果重新生成代码，将丢失对此文件所做的更改。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using TemplateAction.Label.Token;
namespace TemplateAction.Label
{
    public class TemplateSequence : TokenSequence
    {
        public TemplateSequence(string input) : base(input) { }
        public override BaseToken GenerateToken(string input)
        {
            if (input.Length > 0)
            {
                char c = input[0];
                if (StructToken.IsStruct(c))
                {
                    return new StructToken(input);
                }
                else if (c == StringToken.DOUBLE_QUOTES || c == StringToken.SINGLE_QUOTES)
                {
                    return new StringToken(input);
                }
                else if (char.IsDigit(c))
                {
                    return new NumberToken(input);
                }
                else if (c == '$')
                {
                    return new VarToken(input);
                }
                else if (char.IsLetter(c) || c.Equals('_'))
                {
                    return new CharSetToken(input);
                }
            }
            return new UndefinedToken(input);
        }
        protected override void AppendToken(BaseToken token)
        {
            int tPosition = mPosition + token.Length;
            while (tPosition < mTokenInput.Length && token.Append(mTokenInput[tPosition]))
            {
                tPosition++;
            }
        }
        public BaseToken NextTemplate()
        {
            PrepareRead();
            if (IsEnd()) return new UndefinedToken(string.Empty);
            int nextaj = 0;
            int nextbj = 0;
            int nextfuna = 0;
            string rtToken = string.Empty;
            for (int i = mPosition; i < mTokenInput.Length; i++)
            {
                char tmp = mTokenInput[i];
                //判断是否为标签开始
                if (tmp == StructToken.BEGIN_START[nextaj])
                {
                    nextaj++;
                    if (nextaj == StructToken.BEGIN_START.Length)
                    {
                        rtToken = StructToken.BEGIN_START;
                        mPosition = i;
                        break;
                    }
                }
                else
                {
                    nextaj = 0;
                }
                //判断是否为标签结束
                if (tmp == StructToken.END_START[nextbj])
                {
                    nextbj++;
                    if (nextbj == StructToken.END_START.Length)
                    {
                        rtToken = StructToken.END_START;
                        mPosition = i;
                        break;
                    }
                }
                else
                {
                    nextbj = 0;
                }

                //判断是否为函数开始
                if (tmp == StructToken.BEGIN_FUN[0])
                {
                    nextfuna++;
                    rtToken = StructToken.BEGIN_FUN;
                    mPosition = i;
                    break;
                }
                else
                {
                    nextfuna = 0;
                }
            }

            if (nextaj != 0 || nextbj != 0 || nextfuna != 0)
            {
                BaseToken tToken = GenerateToken(rtToken);
                mPosition++;
                if (tToken != null)
                {
                    return tToken;
                }
            }

            mPosition = mTokenInput.Length;
            return new UndefinedToken(string.Empty);
        }
    }

}